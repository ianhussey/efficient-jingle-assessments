---
title: "Simulate bias and precision of Planned Missing Data Designs + FIML estimation vs complete data vs observed correlations"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r include=FALSE}

# formatting options
# set default chunk options
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

# disable scientific notation
options(scipen = 999) 

```

```{r}

# ------------------------------------------------------------
# Planned-Missing Designs: Multi-Factor Simulation Scaffold (R)
# Structure:
#  1) Data generator (multi-factor)
#  1b) Planned-missing (per factor block)
#  2) Analyzer (latent & observed for all factor pairs)
#  3) Runners (one condition, grid)
#  4) Summaries
#  5) Entry points (single condition OR grid)
# ------------------------------------------------------------

# ---- Libraries ----
library(tidyr)
library(dplyr)
library(purrr)
library(furrr)
library(tibble)
library(glue)
library(lavaan)
library(janitor)

# ---- Reproducibility ----
rm(list = ls())
set.seed(42)
# future::plan(multisession)  # optional for parallel

##############################################
# ---- 1) Data Generator (multi-factor) ----
##############################################

# 1.0) Helpers ------------------------------------------------------------

# Make item names per factor (unequal lengths ok)
# items_per_factor: integer vector, e.g., c(5, 8, 4)
make_item_map <- function(items_per_factor, prefix = "S") {
  F <- length(items_per_factor)
  nm <- paste0("F", seq_len(F))
  setNames(lapply(seq_len(F), function(j) paste0(prefix, j, "_", seq_len(items_per_factor[j]))), nm)
}

# Normalize lambda: accept single value or vector length F (one per factor)
normalize_lambda <- function(lambda, F) {
  if (length(lambda) == 1L) rep(lambda, F) else {
    stopifnot(length(lambda) == F); lambda
  }
}

# Simple equicorrelation matrix (if you want same rho between all factors)
make_equicorr <- function(F, rho) {
  R <- matrix(rho, nrow = F, ncol = F); diag(R) <- 1; R
}

# 1.1) Build a POPULATION model (fixed factor correlations) ---------------
# Used for simulateData()
build_pop_model_multi <- function(item_map, lambda = 0.7, R_F) {
  Fnames <- names(item_map)
  F <- length(Fnames)
  lambda_vec <- normalize_lambda(lambda, F)
  
  # loadings: same lambda per factor
  load_lines <- vapply(seq_len(F), function(j) {
    paste0(
      Fnames[j], " =~ ",
      paste(paste0(lambda_vec[j], "*", item_map[[j]]), collapse = " + ")
    )
  }, FUN.VALUE = character(1))
  
  # factor variances (std.lv=TRUE will fix to 1 anyway; harmless to include)
  var_lines <- paste0(Fnames, " ~~ 1*", Fnames)
  
  # factor correlations: use upper triangle of R_F
  cor_lines <- character(0)
  for (i in seq_len(F-1)) for (j in (i+1):F) {
    cor_lines <- c(cor_lines, sprintf("%s ~~ %g*%s", Fnames[i], R_F[i, j], Fnames[j]))
  }
  
  glue::glue(paste(c(load_lines, var_lines, cor_lines), collapse = "\n"))
}

# 1.2) Build an ESTIMATION model (free factor correlations) ---------------
# Used for lavaan::sem()
build_meas_model_multi <- function(item_map, lambda = 0.7) {
  Fnames <- names(item_map)
  F <- length(Fnames)
  lambda_vec <- normalize_lambda(lambda, F)
  
  load_lines <- vapply(seq_len(F), function(j) {
    paste0(
      Fnames[j], " =~ ",
      paste(paste0(lambda_vec[j], "*", item_map[[j]]), collapse = " + ")
    )
  }, FUN.VALUE = character(1))
  
  glue::glue(paste(load_lines, collapse = "\n"))
}

# 1.3) Generate observed item data from the POPULATION model --------------
# items_per_factor: integer vector (e.g., c(5,8,4))
# lambda: scalar or vector length F (one loading per factor)
# R_F: correlation matrix (F x F)
generate_data_multi <- function(n, items_per_factor, lambda = 0.7, R_F, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  item_map   <- make_item_map(items_per_factor)
  pop_model  <- build_pop_model_multi(item_map, lambda = lambda, R_F = R_F)
  df_full <- lavaan::simulateData(
    model        = pop_model,
    sample.nobs  = n,
    standardized = TRUE
  ) |>
    tibble::as_tibble()
  attr(df_full, "item_map") <- item_map
  df_full
}

##############################################################
# ---- 1b) Planned-Missing (block-MCAR per factor) ----
##############################################################

# 1b.1) exact block masking on a numeric matrix ---------------------------
mask_block_exact <- function(mat, prop, rule = c("round","floor","ceiling"), seed = NULL) {
  stopifnot(is.matrix(mat))
  rule <- match.arg(rule)
  if (!is.null(seed)) set.seed(seed)
  
  n <- nrow(mat); k <- ncol(mat)
  if (k == 0L || n == 0L) return(mat)
  
  m <- switch(rule,
              round   = as.integer(round(prop * k)),
              floor   = as.integer(floor(prop * k)),
              ceiling = as.integer(ceiling(prop * k)))
  m <- max(0L, min(k, m))
  
  if (m == 0L) return(mat)
  if (m == k) return(matrix(NA_real_, nrow = n, ncol = k, dimnames = dimnames(mat)))
  
  miss <- matrix(FALSE, nrow = n, ncol = k)
  idx_list <- replicate(n, sample.int(k, size = m, replace = FALSE), simplify = FALSE)
  for (i in seq_len(n)) miss[i, idx_list[[i]]] <- TRUE
  
  mat[miss] <- NA_real_
  mat
}

# 1b.2) Orchestrator over factor blocks ----------------------------------
# prop can be scalar or vector length F (one per factor)
impose_missing_by_factors <- function(df, item_map, prop = 0.50,
                                      rule = c("round","floor","ceiling"),
                                      seed = NULL) {
  rule <- match.arg(rule)
  F <- length(item_map)
  prop_vec <- if (length(prop) == 1L) rep(prop, F) else {
    stopifnot(length(prop) == F); prop
  }
  
  out <- df
  for (j in seq_len(F)) {
    cols <- item_map[[j]]
    out[, cols] <- mask_block_exact(as.matrix(out[, cols, drop = FALSE]),
                                    prop = prop_vec[j], rule = rule, seed = seed)
  }
  out
}

#################################
# ---- 2) Analyzer (multi) ----
#################################

# Row means helper
row_means_safe <- function(data, cols) rowMeans(data[, cols, drop = FALSE], na.rm = TRUE)

# 2.1) Analyze: latent & observed correlations for ALL factor pairs -------
# Returns a tidy table with rows for Fi~~Fj (i<j)
analyze_multi <- function(data, item_map, lambda = 0.7, use_fiml = TRUE, ci_level = 0.95) {
  Fnames    <- names(item_map)
  F         <- length(Fnames)
  
  # Build & fit model (free correlations)
  meas_model <- build_meas_model_multi(item_map, lambda = lambda)
  fit <- lavaan::sem(
    model         = meas_model,
    data          = data,
    meanstructure = TRUE,
    estimator     = "ML",
    std.lv        = TRUE,
    missing       = if (use_fiml) "fiml" else "listwise",
    warn          = FALSE
  )
  
  # LATENT correlations (Fi ~~ Fj)
  pe_lat <- lavaan::parameterEstimates(fit, ci = TRUE, level = ci_level) |>
    dplyr::filter(op == "~~", lhs %in% Fnames, rhs %in% Fnames, lhs < rhs) |>
    dplyr::transmute(
      measure   = "latent",
      factor_i  = lhs,
      factor_j  = rhs,
      est       = est,
      se        = se,
      lwr       = ci.lower,
      upr       = ci.upper,
      converged = lavaan::lavInspect(fit, "converged")
    )
  if (nrow(pe_lat) == 0L) {
    pe_lat <- tibble::tibble(
      measure   = "latent",
      factor_i  = character(0),
      factor_j  = character(0),
      est = double(), se = double(), lwr = double(), upr = double(),
      converged = logical(0)
    )
  }
  
  # OBSERVED: row means per factor, pairwise Pearson r with CI via cor.test
  means_df <- purrr::map_dfc(item_map, ~ row_means_safe(data, .x))
  names(means_df) <- Fnames
  cc <- stats::complete.cases(means_df)
  
  obs_rows <- list()
  if (sum(cc) >= 4L) {
    idx <- which(upper.tri(matrix(NA, F, F)), arr.ind = TRUE)
    for (r in seq_len(nrow(idx))) {
      i <- idx[r, 1]; j <- idx[r, 2]
      xi <- means_df[[i]][cc]; yj <- means_df[[j]][cc]
      ct <- stats::cor.test(xi, yj, conf.level = ci_level)
      obs_rows[[r]] <- tibble::tibble(
        measure   = "observed",
        factor_i  = Fnames[i],
        factor_j  = Fnames[j],
        est       = unname(ct$estimate[[1]]),
        se        = 1 / sqrt(sum(cc) - 3),    # Fisher z SE (reference)
        lwr       = unname(ct$conf.int[1]),
        upr       = unname(ct$conf.int[2]),
        converged = TRUE
      )
    }
  } else {
    obs_rows[[1]] <- tibble::tibble(
      measure   = "observed",
      factor_i  = character(0),
      factor_j  = character(0),
      est = double(), se = double(), lwr = double(), upr = double(),
      converged = logical(0)
    )
  }
  pe_obs <- dplyr::bind_rows(obs_rows)
  
  dplyr::bind_rows(pe_lat, pe_obs)
}

#########################################
# ---- 3) Runners (multi) ----
#########################################

# One replication: generate -> impose missing -> analyze
run_one_multi <- function(n, items_per_factor, lambda, R_F, miss_prop, seed = NULL) {
  df_full <- generate_data_multi(n, items_per_factor, lambda = lambda, R_F = R_F, seed = seed)
  item_map <- attr(df_full, "item_map")
  df_miss <- impose_missing_by_factors(df_full, item_map, prop = miss_prop, seed = seed)
  r_full <- analyze_multi(df_full, item_map, lambda = lambda, use_fiml = FALSE) |>
    dplyr::mutate(dataset = "full")
  r_miss <- analyze_multi(df_miss, item_map, lambda = lambda, use_fiml = TRUE) |>
    dplyr::mutate(dataset = "missing_FIML")
  dplyr::bind_rows(r_full, r_miss)
}

# R replications for one condition; attach metadata (including truth rho_ij if provided)
# Optional: pass r_true_mat (F x F) to attach true correlations per pair.
run_condition_multi <- function(R, n, items_per_factor, lambda, R_F, miss_prop,
                                cond_id = 1, r_true_mat = NULL, seed = NULL) {
  out <- purrr::map_dfr(seq_len(R), function(r) {
    seed_r <- NULL
    run_one_multi(n, items_per_factor, lambda, R_F, miss_prop, seed = seed_r) |>
      dplyr::mutate(
        rep = r,
        cond_id = cond_id,
        n = n,
        items_per_factor = list(items_per_factor),
        lambda = I(list(lambda)),
        miss_prop = I(list(miss_prop))
      )
  })
  
  # attach r_true per (factor_i, factor_j) if matrix provided
  if (!is.null(r_true_mat)) {
    add_truth <- function(df) {
      df |>
        dplyr::rowwise() |>
        dplyr::mutate(r_true = ifelse(!is.na(factor_i) && !is.na(factor_j),
                                      r_true_mat[match(factor_i, rownames(r_true_mat)),
                                                 match(factor_j, colnames(r_true_mat))],
                                      NA_real_)) |>
        dplyr::ungroup()
    }
    out <- add_truth(out)
  }
  
  out
}

# Grid runner (grid must include list-cols for items_per_factor and R_F)
# e.g., expand_grid(n = c(300,500), items_per_factor = list(c(5,8,4)), R_F = list(make_equicorr(3, .5)), ...)
run_grid_multi <- function(grid, .progress = TRUE, seed = TRUE) {
  furrr::future_pmap_dfr(
    .l = list(grid$R, grid$n, grid$items_per_factor, grid$lambda, grid$R_F, grid$miss_prop, seq_len(nrow(grid))),
    .f = function(R, n, items_per_factor, lambda, R_F, miss_prop, cond_id) {
      run_condition_multi(R, n, items_per_factor, lambda, R_F, miss_prop,
                          cond_id = cond_id, r_true_mat = R_F)
    },
    .progress = .progress,
    .options  = furrr::furrr_options(seed = seed)
  )
}

########################
# ---- 4) Summaries ----
########################

# Summarize per condition × dataset × measure × factor pair
summarise_sim_multi <- function(res) {
  res |>
    dplyr::group_by(cond_id, dataset, measure, factor_i, factor_j, .add = TRUE) |>
    dplyr::summarise(
      n_iter         = sum(!is.na(est)),
      converged_prop = mean(converged, na.rm = TRUE),
      mean_est       = mean(est, na.rm = TRUE),
      bias           = mean(est - r_true, na.rm = TRUE),
      rmse           = sqrt(mean((est - r_true)^2, na.rm = TRUE)),
      sd_est         = stats::sd(est, na.rm = TRUE),
      mean_se        = mean(se, na.rm = TRUE),
      mean_ci_width  = mean(upr - lwr, na.rm = TRUE),
      coverage_95    = mean(lwr <= r_true & upr >= r_true, na.rm = TRUE),
      mcse_bias      = ifelse(n_iter > 0, stats::sd(est - r_true, na.rm = TRUE) / sqrt(n_iter), NA_real_),
      mcse_cov95     = ifelse(n_iter > 0, sqrt(coverage_95 * (1 - coverage_95) / n_iter), NA_real_),
      .groups = "drop"
    )
}

#############################################
# ---- 5) Entry Points (user inputs) ----
#############################################

# A) Single condition (example: 3 factors, unequal items) -----------------
F <- 3
items_per_factor <- c(5, 8, 4)
lambda <- c(0.7)            # per-factor loadings (or single value)
R_F <- make_equicorr(F, rho = 0.5)    # or supply your own F x F correlation matrix
miss_prop <- c(0.4)         # per-factor missingness (or single value)
n <- 200
R <- 10

single_res <- run_condition_multi(R, n, items_per_factor, lambda, R_F, miss_prop,
                                  cond_id = 1, r_true_mat = R_F)
single_sum <- summarise_sim_multi(single_res)
print(single_sum)
view(single_sum)

# B) Grid run (vary n & missingness; keep structure fixed) ----------------
experiment_parameters <- tidyr::expand_grid(
  n = c(300, 600),
  items_per_factor = list(c(5,8,4)),
  lambda = list(c(0.7, 0.6, 0.8)),
  R_F = list(make_equicorr(3, 0.5)),
  miss_prop = list(c(0.3, 0.5, 0.4)),
  R = 200
)

# plan(multisession)  # enable if you want parallel
grid_results <- run_grid_multi(experiment_parameters, .progress = TRUE, seed = TRUE)
grid_summary <- summarise_sim_multi(grid_results)
print(grid_summary)

```
